#!/usr/bin/env bash
#
# wctl - Window Control CLI
# A wrapper for the GNOME Shell Window Control D-Bus extension
#

set -euo pipefail

# D-Bus service details
DBUS_DEST="org.gnome.Shell"
DBUS_PATH="/org/gnome/Shell/Extensions/WindowControl"
DBUS_IFACE="org.gnome.Shell.Extensions.WindowControl"

# Colors for output (disabled if not a tty)
if [[ -t 1 ]]; then
    BOLD='\033[1m'
    DIM='\033[2m'
    GREEN='\033[32m'
    YELLOW='\033[33m'
    RED='\033[31m'
    RESET='\033[0m'
else
    BOLD=''
    DIM=''
    GREEN=''
    YELLOW=''
    RED=''
    RESET=''
fi

# Version
VERSION="0.4.0"

# Print error message and exit
die() {
    echo -e "${RED}Error:${RESET} $1" >&2
    exit 1
}

# Check if required tools are available
check_dependencies() {
    if ! command -v busctl &>/dev/null; then
        die "busctl not found. Install systemd or systemd-libs package."
    fi
    if ! command -v jq &>/dev/null; then
        die "jq not found. Install jq package."
    fi
}

# Check if the Window Control extension is installed and enabled
check_extension() {
    # Check dependencies first
    check_dependencies
    
    # Check if extension is installed
    if ! gnome-extensions list 2>/dev/null | grep -q "window-control@hko9890"; then
        die "Window Control extension is not installed.

Install it with:
    gnome-extensions install window-control@hko9890

Or copy manually:
    cp -r window-control@hko9890 ~/.local/share/gnome-shell/extensions/

Then restart GNOME Shell (log out/in on Wayland) and enable the extension."
    fi

    # Check if extension is enabled
    if ! gnome-extensions list --enabled 2>/dev/null | grep -q "window-control@hko9890"; then
        die "Window Control extension is installed but not enabled.

Enable it with:
    gnome-extensions enable window-control@hko9890"
    fi
}

# Call D-Bus method and return raw output (GVariant format)
# Usage: dbus_call METHOD [ARGS...]
dbus_call() {
    local method="$1"
    shift
    
    local result
    if ! result=$(gdbus call --session \
        --dest "$DBUS_DEST" \
        --object-path "$DBUS_PATH" \
        --method "${DBUS_IFACE}.${method}" \
        "$@" 2>&1); then
        
        # Check for common errors
        if [[ "$result" == *"was not provided"* ]] || [[ "$result" == *"does not exist"* ]]; then
            die "Window Control extension is not running. Enable it in GNOME Extensions."
        fi
        die "D-Bus call failed: $result"
    fi
    
    echo "$result"
}

# Call D-Bus method and return JSON output (using busctl)
# Usage: dbus_call_json METHOD
# Returns: JSON string from D-Bus string return value
dbus_call_json() {
    local method="$1"
    
    local result
    if ! result=$(busctl --user call --json=short \
        "$DBUS_DEST" \
        "$DBUS_PATH" \
        "$DBUS_IFACE" \
        "$method" 2>&1); then
        
        # Check for common errors
        if [[ "$result" == *"No route to host"* ]] || [[ "$result" == *"not found"* ]]; then
            die "Window Control extension is not running. Enable it in GNOME Extensions."
        fi
        die "D-Bus call failed: $result"
    fi
    
    # busctl --json returns: {"type":"s","data":["JSON_STRING"]}
    # Extract the actual JSON string from data[0]
    echo "$result" | jq -r '.data[0]'
}

# Truncate string to max length with ellipsis
truncate() {
    local str="$1"
    local max="$2"
    
    if [[ ${#str} -gt $max ]]; then
        echo "${str:0:$((max-3))}..."
    else
        echo "$str"
    fi
}

# Show help message
show_help() {
    cat << EOF
wctl $VERSION - Window Control CLI

USAGE:
    wctl <COMMAND> [OPTIONS]

LISTING COMMANDS:
    list              List all windows in a table format
    list --json       List all windows with detailed JSON output
    focused           Show detailed info for the focused window
    focused --json    Show focused window info as JSON

ACTIVATION COMMANDS:
    activate <ID>           Activate by window ID
    activate -t <TITLE>     Activate by exact title match
    activate -s <SUBSTR>    Activate by title substring
    activate -c <CLASS>     Activate by WM class
    activate -p <PID>       Activate by process ID
    focus <ID>              Focus window by ID (without raising)

INFO COMMANDS:
    info <ID>             Show detailed window information
    info <ID> --json      Show window information as JSON

GEOMETRY COMMANDS:
    move <ID> <X> <Y>                   Move window to position
    resize <ID> <WIDTH> <HEIGHT>        Resize window
    move-resize <ID> <X> <Y> <W> <H>    Move and resize atomically

TILING & POSITIONING:
    tile <ID> <position>                Tile window to 4x2 grid position
    center <ID> [horizontal|vertical|both]  Center window on screen

STATE COMMANDS:
    minimize <ID>           Minimize window
    unminimize <ID>         Restore from minimize
    maximize <ID>           Maximize window
    unmaximize <ID>         Restore from maximize
    fullscreen <ID>         Make window fullscreen
    unfullscreen <ID>       Exit fullscreen mode
    above <ID> on|off       Set always-on-top state
    sticky <ID> on|off      Set sticky (all workspaces) state
    close <ID>              Close window (polite request)

OTHER:
    help                    Show this help message
    completion <SHELL>      Output shell completion script (bash or zsh)

EXAMPLES:
    wctl list                         # Show all windows
    wctl list --json                  # Get detailed JSON output
    wctl focused                      # Show detailed focused window info
    wctl focused --json               # Get focused window as JSON
    wctl activate 12345               # Activate window by ID
    wctl activate -c Firefox          # Activate Firefox window
    wctl activate -s "Visual"         # Activate window with "Visual" in title
    wctl info 12345                   # Show detailed window info
    wctl info 12345 --json            # Get window info as JSON
    wctl move 12345 100 100           # Move window to (100, 100)
    wctl resize 12345 800 600         # Resize to 800x600
    wctl tile 12345 top-left          # Tile to top-left of 4x2 grid
    wctl tile 12345 center            # Tile to center of grid
    wctl center 12345                 # Center on screen (both axes)
    wctl center 12345 horizontal      # Center horizontally only
    wctl maximize 12345               # Maximize window
    wctl above 12345 on               # Set always-on-top
    wctl close 12345                  # Close window

SHELL COMPLETION:
    Bash: wctl completion bash > ~/.local/share/bash-completion/completions/wctl
    Zsh:  wctl completion zsh > ~/.local/share/zsh/site-functions/_wctl

ENVIRONMENT:
    The Window Control GNOME Shell extension must be enabled.

EOF
}

# List windows in table format
cmd_list() {
    # Use JSON output with jq for proper unicode handling
    local json
    json=$(dbus_call_json "ListDetailed")
    
    # Check for empty list
    local count
    count=$(echo "$json" | jq 'length')
    if [[ "$count" -eq 0 ]]; then
        echo "No windows found."
        return
    fi
    
    # Format as table using jq and column for proper unicode alignment
    {
        # Header
        echo -e "${BOLD}ID\tTITLE\tCLASS\tWS\tMON\tF${RESET}"
        
        # Data rows - truncate title to 35 chars, format workspace
        echo "$json" | jq -r '.[] | [
            .id,
            (if (.title | length) > 35 then (.title | .[0:32] + "...") else .title end),
            .wm_class,
            (if .workspace_index == -1 then "all" else .workspace_index end),
            .monitor_index,
            (if .has_focus then "*" else "" end)
        ] | @tsv'
    } | column -t -s $'\t'
}

# List windows as JSON (detailed)
cmd_list_json() {
    dbus_call_json "ListDetailed"
}

# Activate a window
# Usage: cmd_activate [OPTIONS] [ID]
cmd_activate() {
    local mode="id"
    local value=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t)
                mode="title"
                shift
                [[ $# -eq 0 ]] && die "Option -t requires a title argument"
                value="$1"
                shift
                ;;
            -s)
                mode="substring"
                shift
                [[ $# -eq 0 ]] && die "Option -s requires a substring argument"
                value="$1"
                shift
                ;;
            -c)
                mode="class"
                shift
                [[ $# -eq 0 ]] && die "Option -c requires a WM class argument"
                value="$1"
                shift
                ;;
            -p)
                mode="pid"
                shift
                [[ $# -eq 0 ]] && die "Option -p requires a PID argument"
                value="$1"
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                # Positional argument (window ID)
                mode="id"
                value="$1"
                shift
                ;;
        esac
    done
    
    [[ -z "$value" ]] && die "Usage: wctl activate <ID> or wctl activate -t|-s|-c|-p <value>"
    
    local raw success
    case "$mode" in
        id)
            # Validate numeric ID
            [[ ! "$value" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
            raw=$(dbus_call "Activate" "$value")
            ;;
        title)
            raw=$(dbus_call "ActivateByTitle" "$value")
            ;;
        substring)
            raw=$(dbus_call "ActivateByTitleSubstring" "$value")
            ;;
        class)
            raw=$(dbus_call "ActivateByWmClass" "$value")
            ;;
        pid)
            # Validate numeric PID
            [[ ! "$value" =~ ^[0-9]+$ ]] && die "PID must be a number"
            raw=$(dbus_call "ActivateByPid" "$value")
            ;;
    esac
    
    # Parse result - format is (true,) or (false,)
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window activated"
    else
        echo "Window not found"
        exit 1
    fi
}

# Focus a window by ID (without raising)
cmd_focus() {
    local id="${1:-}"
    
    [[ -z "$id" ]] && die "Usage: wctl focus <ID>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local raw
    raw=$(dbus_call "Focus" "$id")
    
    # Parse result - format is (true,) or (false,)
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window focused"
    else
        echo "Window not found"
        exit 1
    fi
}

# Show focused window
# Usage: cmd_focused [--json]
cmd_focused() {
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                die "Unexpected argument: $1"
                ;;
        esac
    done
    
    # Get focused window ID from JSON list
    local json id
    json=$(dbus_call_json "ListDetailed")
    id=$(echo "$json" | jq -r '.[] | select(.has_focus == true) | .id // empty')
    
    if [[ -z "$id" ]]; then
        echo "No window focused"
        return
    fi
    
    # Delegate to cmd_info
    if [[ "$json_output" == true ]]; then
        cmd_info "$id" --json
    else
        cmd_info "$id"
    fi
}

# ============================================================================
# Info Commands
# ============================================================================

# Show detailed info for a single window
# Usage: cmd_info <ID> [--json]
cmd_info() {
    local id=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                if [[ -z "$id" ]]; then
                    id="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done
    
    [[ -z "$id" ]] && die "Usage: wctl info <ID> [--json]"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    # Get detailed window list as JSON
    local json
    json=$(dbus_call_json "ListDetailed")
    
    # Find the window with matching ID using jq
    local window
    window=$(echo "$json" | jq -e --arg id "$id" '.[] | select(.id == ($id | tonumber))' 2>/dev/null) || {
        echo "Window not found: $id"
        exit 1
    }
    
    if [[ "$json_output" == true ]]; then
        echo "$window"
    else
        # Format output using jq with aligned labels
        echo "$window" | jq -r '
            "Window:    \(.id)",
            "Title:     \(.title)",
            "Class:     \(.wm_class)",
            "Instance:  \(.wm_class_instance)",
            "PID:       \(.pid)",
            "Workspace: \(if .workspace_index == -1 then "all" else .workspace_index end)",
            "Monitor:   \(.monitor_index)",
            "Focused:   \(if .has_focus then "yes" else "no" end)",
            "Position:  \(.frame_rect.x), \(.frame_rect.y)",
            "Size:      \(.frame_rect.width) x \(.frame_rect.height)",
            "States:    \([
                (if .is_maximized then "maximized" else empty end),
                (if .is_minimized then "minimized" else empty end),
                (if .is_fullscreen then "fullscreen" else empty end),
                (if .is_above then "above" else empty end),
                (if .is_on_all_workspaces then "sticky" else empty end)
            ] | if length == 0 then "none" else join(", ") end)"
        '
    fi
}

# ============================================================================
# Geometry Commands
# ============================================================================

# Move window
cmd_move() {
    local id="${1:-}"
    local x="${2:-}"
    local y="${3:-}"
    
    [[ -z "$id" || -z "$x" || -z "$y" ]] && die "Usage: wctl move <ID> <X> <Y>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$x" =~ ^-?[0-9]+$ ]] && die "X coordinate must be a number"
    [[ ! "$y" =~ ^-?[0-9]+$ ]] && die "Y coordinate must be a number"
    
    local raw
    raw=$(dbus_call "Move" "$id" "$x" "$y")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window moved"
    else
        echo "Window not found"
        exit 1
    fi
}

# Resize window
cmd_resize() {
    local id="${1:-}"
    local width="${2:-}"
    local height="${3:-}"
    
    [[ -z "$id" || -z "$width" || -z "$height" ]] && die "Usage: wctl resize <ID> <WIDTH> <HEIGHT>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$width" =~ ^[0-9]+$ ]] && die "Width must be a positive number"
    [[ ! "$height" =~ ^[0-9]+$ ]] && die "Height must be a positive number"
    
    local raw
    raw=$(dbus_call "Resize" "$id" "$width" "$height")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window resized"
    else
        echo "Window not found"
        exit 1
    fi
}

# Move and resize window
cmd_move_resize() {
    local id="${1:-}"
    local x="${2:-}"
    local y="${3:-}"
    local width="${4:-}"
    local height="${5:-}"
    
    [[ -z "$id" || -z "$x" || -z "$y" || -z "$width" || -z "$height" ]] && \
        die "Usage: wctl move-resize <ID> <X> <Y> <WIDTH> <HEIGHT>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$x" =~ ^-?[0-9]+$ ]] && die "X coordinate must be a number"
    [[ ! "$y" =~ ^-?[0-9]+$ ]] && die "Y coordinate must be a number"
    [[ ! "$width" =~ ^[0-9]+$ ]] && die "Width must be a positive number"
    [[ ! "$height" =~ ^[0-9]+$ ]] && die "Height must be a positive number"
    
    local raw
    raw=$(dbus_call "MoveResize" "$id" "$x" "$y" "$width" "$height")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window moved and resized"
    else
        echo "Window not found"
        exit 1
    fi
}

# ============================================================================
# Tiling & Positioning Commands
# ============================================================================

# Tile window to grid position
cmd_tile() {
    local id="${1:-}"
    local position="${2:-}"
    
    [[ -z "$id" || -z "$position" ]] && die "Usage: wctl tile <ID> <position>
Valid positions:
  top-left, top-center, top-right
  left, center, right
  bottom-left, bottom-center, bottom-right"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    # Get window info to find monitor
    local json window
    json=$(dbus_call_json "ListDetailed")
    window=$(echo "$json" | jq -e --arg id "$id" '.[] | select(.id == ($id | tonumber))' 2>/dev/null) || {
        die "Window not found: $id"
    }
    
    local monitor_index
    monitor_index=$(echo "$window" | jq -r '.monitor_index')
    
    # Get workarea for window's monitor
    local raw
    raw=$(dbus_call "GetWorkarea" "$monitor_index")
    
    # Parse workarea - format is (x, y, width, height)
    local wa_x wa_y wa_w wa_h
    if [[ "$raw" =~ ^\(([0-9]+),\ ([0-9]+),\ ([0-9]+),\ ([0-9]+)\)$ ]]; then
        wa_x="${BASH_REMATCH[1]}"
        wa_y="${BASH_REMATCH[2]}"
        wa_w="${BASH_REMATCH[3]}"
        wa_h="${BASH_REMATCH[4]}"
    else
        die "Failed to parse workarea: $raw"
    fi
    
    # Calculate grid cell dimensions (4x2 grid)
    local cell_w=$((wa_w / 4))
    local cell_h=$((wa_h / 2))
    
    # Map position to grid coordinates
    local start_col end_col start_row end_row
    case "$position" in
        top-left)
            start_col=0 end_col=0 start_row=0 end_row=0
            ;;
        top-center)
            start_col=1 end_col=2 start_row=0 end_row=0
            ;;
        top-right)
            start_col=3 end_col=3 start_row=0 end_row=0
            ;;
        left)
            start_col=0 end_col=0 start_row=0 end_row=1
            ;;
        center)
            start_col=1 end_col=2 start_row=0 end_row=1
            ;;
        right)
            start_col=3 end_col=3 start_row=0 end_row=1
            ;;
        bottom-left)
            start_col=0 end_col=0 start_row=1 end_row=1
            ;;
        bottom-center)
            start_col=1 end_col=2 start_row=1 end_row=1
            ;;
        bottom-right)
            start_col=3 end_col=3 start_row=1 end_row=1
            ;;
        *)
            die "Invalid position: $position
Valid positions:
  top-left, top-center, top-right
  left, center, right
  bottom-left, bottom-center, bottom-right"
            ;;
    esac
    
    # Calculate pixel positions
    local x=$((wa_x + cell_w * start_col))
    local y=$((wa_y + cell_h * start_row))
    local width=$((cell_w * (end_col - start_col + 1)))
    local height=$((cell_h * (end_row - start_row + 1)))
    
    # Call MoveResize to position window
    raw=$(dbus_call "MoveResize" "$id" "$x" "$y" "$width" "$height")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window tiled to $position"
    else
        echo "Window not found"
        exit 1
    fi
}

# Center window on screen
cmd_center() {
    local id="${1:-}"
    local axis="${2:-both}"
    
    [[ -z "$id" ]] && die "Usage: wctl center <ID> [horizontal|vertical|both]"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    # Normalize axis argument (support short forms)
    case "$axis" in
        h|horizontal)
            axis="horizontal"
            ;;
        v|vertical)
            axis="vertical"
            ;;
        both|"")
            axis="both"
            ;;
        *)
            die "Invalid axis: $axis. Must be 'horizontal', 'vertical', or 'both'"
            ;;
    esac
    
    # Get window info
    local json window
    json=$(dbus_call_json "ListDetailed")
    window=$(echo "$json" | jq -e --arg id "$id" '.[] | select(.id == ($id | tonumber))' 2>/dev/null) || {
        die "Window not found: $id"
    }
    
    # Get current window geometry
    local win_x win_y win_w win_h
    win_x=$(echo "$window" | jq -r '.frame_rect.x')
    win_y=$(echo "$window" | jq -r '.frame_rect.y')
    win_w=$(echo "$window" | jq -r '.frame_rect.width')
    win_h=$(echo "$window" | jq -r '.frame_rect.height')
    
    # Get monitor index
    local monitor_index
    monitor_index=$(echo "$window" | jq -r '.monitor_index')
    
    # Get workarea for window's monitor
    local raw
    raw=$(dbus_call "GetWorkarea" "$monitor_index")
    
    # Parse workarea - format is (x, y, width, height)
    local wa_x wa_y wa_w wa_h
    if [[ "$raw" =~ ^\(([0-9]+),\ ([0-9]+),\ ([0-9]+),\ ([0-9]+)\)$ ]]; then
        wa_x="${BASH_REMATCH[1]}"
        wa_y="${BASH_REMATCH[2]}"
        wa_w="${BASH_REMATCH[3]}"
        wa_h="${BASH_REMATCH[4]}"
    else
        die "Failed to parse workarea: $raw"
    fi
    
    # Calculate centered positions
    local new_x="$win_x"
    local new_y="$win_y"
    
    if [[ "$axis" == "horizontal" || "$axis" == "both" ]]; then
        new_x=$((wa_x + (wa_w - win_w) / 2))
    fi
    
    if [[ "$axis" == "vertical" || "$axis" == "both" ]]; then
        new_y=$((wa_y + (wa_h - win_h) / 2))
    fi
    
    # Call Move to reposition window (preserve size)
    raw=$(dbus_call "Move" "$id" "$new_x" "$new_y")
    
    if [[ "$raw" == "(true,)" ]]; then
        case "$axis" in
            horizontal)
                echo "Window centered horizontally"
                ;;
            vertical)
                echo "Window centered vertically"
                ;;
            both)
                echo "Window centered"
                ;;
        esac
    else
        echo "Window not found"
        exit 1
    fi
}

# ============================================================================
# State Commands
# ============================================================================

# Helper for simple window state commands
# Usage: cmd_simple_state METHOD MESSAGE_SUCCESS
cmd_simple_state() {
    local method="$1"
    local success_msg="$2"
    local id="${3:-}"
    
    [[ -z "$id" ]] && die "Usage: wctl ${method,,} <ID>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local raw
    raw=$(dbus_call "$method" "$id")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "$success_msg"
    else
        echo "Window not found"
        exit 1
    fi
}

cmd_minimize() {
    cmd_simple_state "Minimize" "Window minimized" "$@"
}

cmd_unminimize() {
    cmd_simple_state "Unminimize" "Window unminimized" "$@"
}

cmd_maximize() {
    cmd_simple_state "Maximize" "Window maximized" "$@"
}

cmd_unmaximize() {
    cmd_simple_state "Unmaximize" "Window unmaximized" "$@"
}

cmd_fullscreen() {
    cmd_simple_state "Fullscreen" "Window fullscreened" "$@"
}

cmd_unfullscreen() {
    cmd_simple_state "Unfullscreen" "Window unfullscreened" "$@"
}

cmd_close() {
    cmd_simple_state "Close" "Window closed" "$@"
}

# Set above (always-on-top) state
cmd_above() {
    local id="${1:-}"
    local state="${2:-}"
    
    [[ -z "$id" || -z "$state" ]] && die "Usage: wctl above <ID> on|off"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local above
    case "$state" in
        on|true|1)
            above="true"
            ;;
        off|false|0)
            above="false"
            ;;
        *)
            die "State must be 'on' or 'off'"
            ;;
    esac
    
    local raw
    raw=$(dbus_call "SetAbove" "$id" "$above")
    
    if [[ "$raw" == "(true,)" ]]; then
        if [[ "$above" == "true" ]]; then
            echo "Window set to always-on-top"
        else
            echo "Window removed from always-on-top"
        fi
    else
        echo "Window not found"
        exit 1
    fi
}

# Output bash completion script
cmd_completion_bash() {
    cat << 'BASH_COMPLETION'
# Bash completion for wctl
# Install: wctl completion bash > ~/.local/share/bash-completion/completions/wctl

_wctl_get_window_ids() {
    local ids
    ids=$(wctl list --json 2>/dev/null | jq -r '.[].id' 2>/dev/null)
    echo "$ids"
}

_wctl() {
    local cur prev words cword
    _init_completion || return

    local commands="list focused info activate focus move resize move-resize minimize unminimize maximize unmaximize fullscreen unfullscreen above sticky close help completion"
    local id_commands="info focus move resize move-resize minimize unminimize maximize unmaximize fullscreen unfullscreen above sticky close"

    # Complete command names
    if [[ $cword -eq 1 ]]; then
        COMPREPLY=($(compgen -W "$commands" -- "$cur"))
        return
    fi

    local cmd="${words[1]}"

    case "$cmd" in
        list|focused)
            COMPREPLY=($(compgen -W "--json" -- "$cur"))
            ;;
        info)
            if [[ $cword -eq 2 ]]; then
                COMPREPLY=($(compgen -W "$(_wctl_get_window_ids)" -- "$cur"))
            elif [[ $cword -eq 3 ]]; then
                COMPREPLY=($(compgen -W "--json" -- "$cur"))
            fi
            ;;
        activate)
            if [[ $cword -eq 2 ]]; then
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($(compgen -W "-t -s -c -p" -- "$cur"))
                else
                    COMPREPLY=($(compgen -W "-t -s -c -p $(_wctl_get_window_ids)" -- "$cur"))
                fi
            fi
            ;;
        above|sticky)
            if [[ $cword -eq 2 ]]; then
                COMPREPLY=($(compgen -W "$(_wctl_get_window_ids)" -- "$cur"))
            elif [[ $cword -eq 3 ]]; then
                COMPREPLY=($(compgen -W "on off" -- "$cur"))
            fi
            ;;
        completion)
            if [[ $cword -eq 2 ]]; then
                COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
            fi
            ;;
        focus|move|resize|move-resize|minimize|unminimize|maximize|unmaximize|fullscreen|unfullscreen|close)
            if [[ $cword -eq 2 ]]; then
                COMPREPLY=($(compgen -W "$(_wctl_get_window_ids)" -- "$cur"))
            fi
            ;;
    esac
}

complete -F _wctl wctl
BASH_COMPLETION
}

# Output zsh completion script
cmd_completion_zsh() {
    cat << 'ZSH_COMPLETION'
#compdef wctl
# Zsh completion for wctl
# Install: wctl completion zsh > ~/.local/share/zsh/site-functions/_wctl

_wctl_window_ids() {
    local -a windows
    local json
    json=$(wctl list --json 2>/dev/null) || return
    
    # Parse JSON and create completion entries with descriptions
    while IFS=$'\t' read -r id title; do
        # Truncate long titles
        if [[ ${#title} -gt 50 ]]; then
            title="${title:0:47}..."
        fi
        windows+=("$id:$title")
    done < <(echo "$json" | jq -r '.[] | [.id, .title] | @tsv' 2>/dev/null)
    
    _describe -t windows 'window' windows
}

_wctl() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    local -a commands=(
        'list:List all windows'
        'focused:Show focused window info'
        'info:Show detailed window info'
        'activate:Activate a window'
        'focus:Focus window without raising'
        'move:Move window to position'
        'resize:Resize window'
        'move-resize:Move and resize window'
        'minimize:Minimize window'
        'unminimize:Restore from minimize'
        'maximize:Maximize window'
        'unmaximize:Restore from maximize'
        'fullscreen:Make window fullscreen'
        'unfullscreen:Exit fullscreen'
        'above:Set always-on-top state'
        'sticky:Set sticky (all workspaces) state'
        'close:Close window'
        'help:Show help message'
        'completion:Output shell completion script'
    )

    _arguments -C \
        '1:command:->command' \
        '*::args:->args'

    case $state in
        command)
            _describe -t commands 'wctl command' commands
            ;;
        args)
            case $words[1] in
                list|focused)
                    _arguments '--json[Output as JSON]'
                    ;;
                info)
                    _arguments \
                        '1:window id:_wctl_window_ids' \
                        '--json[Output as JSON]'
                    ;;
                activate)
                    _arguments \
                        '(-t -s -c -p)1:window id:_wctl_window_ids' \
                        '(-s -c -p)-t[Activate by exact title]:title:' \
                        '(-t -c -p)-s[Activate by title substring]:substring:' \
                        '(-t -s -p)-c[Activate by WM class]:class:' \
                        '(-t -s -c)-p[Activate by PID]:pid:'
                    ;;
                focus|minimize|unminimize|maximize|unmaximize|fullscreen|unfullscreen|close)
                    _arguments '1:window id:_wctl_window_ids'
                    ;;
                move)
                    _arguments \
                        '1:window id:_wctl_window_ids' \
                        '2:x position:' \
                        '3:y position:'
                    ;;
                resize)
                    _arguments \
                        '1:window id:_wctl_window_ids' \
                        '2:width:' \
                        '3:height:'
                    ;;
                move-resize)
                    _arguments \
                        '1:window id:_wctl_window_ids' \
                        '2:x position:' \
                        '3:y position:' \
                        '4:width:' \
                        '5:height:'
                    ;;
                above|sticky)
                    _arguments \
                        '1:window id:_wctl_window_ids' \
                        '2:state:(on off)'
                    ;;
                completion)
                    _arguments '1:shell:(bash zsh)'
                    ;;
            esac
            ;;
    esac
}

_wctl "$@"
ZSH_COMPLETION
}

# Set sticky (all workspaces) state
cmd_sticky() {
    local id="${1:-}"
    local state="${2:-}"
    
    [[ -z "$id" || -z "$state" ]] && die "Usage: wctl sticky <ID> on|off"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local sticky
    case "$state" in
        on|true|1)
            sticky="true"
            ;;
        off|false|0)
            sticky="false"
            ;;
        *)
            die "State must be 'on' or 'off'"
            ;;
    esac
    
    local raw
    raw=$(dbus_call "SetSticky" "$id" "$sticky")
    
    if [[ "$raw" == "(true,)" ]]; then
        if [[ "$sticky" == "true" ]]; then
            echo "Window set to all workspaces"
        else
            echo "Window removed from all workspaces"
        fi
    else
        echo "Window not found"
        exit 1
    fi
}

# Main entry point
main() {
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    local cmd="$1"
    shift
    
    # Skip extension check for help, version, and completion commands
    case "$cmd" in
        help|--help|-h)
            show_help
            exit 0
            ;;
        version|--version|-v)
            echo "wctl $VERSION"
            exit 0
            ;;
        completion)
            local shell="${1:-}"
            case "$shell" in
                bash)
                    cmd_completion_bash
                    exit 0
                    ;;
                zsh)
                    cmd_completion_zsh
                    exit 0
                    ;;
                "")
                    die "Usage: wctl completion <bash|zsh>"
                    ;;
                *)
                    die "Unknown shell: $shell. Supported: bash, zsh"
                    ;;
            esac
            ;;
    esac
    
    # Check extension is installed and enabled before running commands
    check_extension
    
    case "$cmd" in
        # Listing commands
        list)
            if [[ "${1:-}" == "--json" ]]; then
                cmd_list_json
            else
                cmd_list
            fi
            ;;
        focused)
            cmd_focused "$@"
            ;;
        
        # Info commands
        info)
            cmd_info "$@"
            ;;
        
        # Activation commands
        activate)
            cmd_activate "$@"
            ;;
        focus)
            cmd_focus "$@"
            ;;
        
        # Geometry commands
        move)
            cmd_move "$@"
            ;;
        resize)
            cmd_resize "$@"
            ;;
        move-resize)
            cmd_move_resize "$@"
            ;;
        
        # Tiling & Positioning commands
        tile)
            cmd_tile "$@"
            ;;
        center)
            cmd_center "$@"
            ;;
        
        # State commands
        minimize)
            cmd_minimize "$@"
            ;;
        unminimize)
            cmd_unminimize "$@"
            ;;
        maximize)
            cmd_maximize "$@"
            ;;
        unmaximize)
            cmd_unmaximize "$@"
            ;;
        fullscreen)
            cmd_fullscreen "$@"
            ;;
        unfullscreen)
            cmd_unfullscreen "$@"
            ;;
        above)
            cmd_above "$@"
            ;;
        sticky)
            cmd_sticky "$@"
            ;;
        close)
            cmd_close "$@"
            ;;
        
        *)
            die "Unknown command: $cmd. Run 'wctl help' for usage."
            ;;
    esac
}

main "$@"
